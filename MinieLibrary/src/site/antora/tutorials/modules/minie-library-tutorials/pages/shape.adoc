= Choosing collision shapes
:item: &rarr;
:url-enwiki: https://en.wikipedia.org/wiki
:url-shape: https://stephengold.github.io/Minie/minie/javadoc/com/jme3/bullet/collision/shapes
:url-tutorial: https://github.com/stephengold/Minie/blob/master/MinieExamples/src/main/java/jme3utilities/tutorial

A _collision shape_
describes the shape and size of a collision object such as a rigid body.

== The 16 shape classes

The examples so far have all used spheres, cubes, and/or cylinders.
However, those are but 3 of the 16 subclasses of the
{url-shape}/CollisionShape.html[`CollisionShape`].

Here they are in lexicographic order,
with illustrations and lists of key properties (explained below):

[cols="2*",grid="none"]
|===

|1. {url-shape}/Box2dShape.html[`Box2dShape`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable +
{item} symmetric
|image:box2d.png[height=160]

|2. {url-shape}/BoxCollisionShape.html[`BoxCollisionShape`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable +
{item} symmetric
|image:https://i.imgur.com/My74h2Q.png[height=160]

|3. {url-shape}/CapsuleCollisionShape.html[`CapsuleCollisionShape`]

{item} convex +
{item} zero margin +
{item} precise +
{item} uniform scaling only +
{item} symmetric
|image:https://i.imgur.com/R9NMEwc.png[height=160]

|4. {url-shape}/CompoundCollisionShape.html[`CompoundCollisionShape`]

{item} neither concave nor convex +
{item} positive margin +
{item} precise if-and-only-if all of its children are precise +
{item} scalable to the extent that all of its children are scalable
|image:https://i.imgur.com/gL6rgAA.png[height=160]

|5. {url-shape}/ConeCollisionShape.html[`ConeCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} uniform scaling only +
{item} symmetric
|image:https://i.imgur.com/jZFVxQd.png[height=160]

|6. {url-shape}/Convex2dShape.html[`Convex2dShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} scalable to the extent that its base shape is scalable
|image:convex2d.png[height=160]

|7. {url-shape}/CylinderCollisionShape.html[`CylinderCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} limited scalability +
{item} symmetric
|image:https://i.imgur.com/ey249X8.png[height=160]

|8. {url-shape}/EmptyShape.html[`EmptyShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable, but why bother? +
{item} symmetric
|(no image)

|9. {url-shape}/GImpactCollisionShape.html[`GImpactCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/TOLRsig.png[height=160]

|10. {url-shape}/HeightfieldCollisionShape.html[`HeightfieldCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/JwtpqOM.png[height=160]

|11. {url-shape}/HullCollisionShape.html[`HullCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} fully scalable
|image:https://i.imgur.com/Rf61rcw.png[height=160]

|12. {url-shape}/MeshCollisionShape.html[`MeshCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/glB3Ujk.png[height=160]

|13. {url-shape}/MultiSphere.html[`MultiSphere`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:https://i.imgur.com/nTZEc8C.png[height=160]

|14. {url-shape}/PlaneCollisionShape.html[`PlaneCollisionShape`]

{item} concave and infinite +
{item} positive margin +
{item} precise +
{item} fully scalable, but why bother? +
{item} symmetric
|image:plane.png[height=160]

|15. {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} not scalable
|image:https://i.imgur.com/l1fYSfc.png[height=160]

|16. {url-shape}/SphereCollisionShape.html[`SphereCollisionShape`]

{item} convex +
{item} zero margin +
{item} precise +
{item} uniform scaling only +
{item} symmetric
|image:https://i.imgur.com/OPYrxRe.png[height=160]

|===

== Convex versus concave

The _convex_ collision-shape classes are those
that guarantee the _convex property_:
for any 2 locations inside a shape,
the line segment connecting those locations lies entirely inside the shape.

Here are 2 equivalent ways to test whether a shape belongs to a convex class:

[source,java]
----
boolean convexClass = (shape instanceof ConvexShape);
boolean isConvex = shape.isConvex();
assert convexClass == isConvex;
----

NOTE: In this context, "convex" is a property of classes, not instances.
While specific *instances* of non-convex classes have the convex property,
they don't guarantee it for *all* instances.

_Concave_ is essentially the opposite of convex, except that compound shapes
are regarded as neither convex nor concave.
No shape is both convex and concave.
To test whether a shape belongs to a concave class, use `shape.isConcave()`.

== Margin

All collision shapes except
{url-shape}/CapsuleCollisionShape.html[`CapsuleCollisionShape`]
and
{url-shape}/SphereCollisionShape.html[`SphereCollisionShape`]
incorporate a _margin_, a narrow zone near the surface of the shape.
(The word _margin_ is used to refer to both the zone and its thickness.)
According to the Bullet Manual, the purpose of margin is
"to improve performance and reliability of the collision detection."

For all shapes with margin, the default thickness is 0.04 physics-space units.

NOTE: While methods are provided to alter margins (and the default margin),
doing so is not recommended.

== Precise versus imprecise

A _precise shape_ is a collision shape whose _effective shape_
(observed in collisions, contact tests, ray tests, and sweep tests)
is unaffected by margin.

While most of the `CollisionShape` subtypes are precise,
there are 5 that are not.
For 4 of them, margin simply expands their effective shapes:

* {url-shape}/ConeCollisionShape.html[`ConeCollisionShape`]
* {url-shape}/Convex2dShape.html[`Convex2dShape`]
* {url-shape}/HullCollisionShape.html[`HullCollisionShape`]
* {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`]

Margin also distorts a
{url-shape}/CylinderCollisionShape.html[`CylinderCollisionShape`],
but its effect is more complicated.

Since margin is defined in physics-space units,
its effects tend become more noticeable for smaller shapes.

When using imprecise shapes, you may compensate for margin
by shrinking the shape's dimensions
(for a {url-shape}/ConeCollisionShape.html[`ConeCollisionShape`] or
{url-shape}/CylinderCollisionShape.html[`CylinderCollisionShape`])
or by moving its defining vertices inward
(for a {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`] or
{url-shape}/HullCollisionShape.html[`HullCollisionShape`]).

Another possible workaround would be to scale the physics space
so as to make the effects of margin less obvious.

== Suitability for dynamic bodies

Not all collision shapes are suitable for dynamic rigid bodies.

For instance,
collision detection doesn't work well between zero-thickness shapes such as:

* {url-shape}/Box2dShape.html[`Box2dShape`]
* {url-shape}/Convex2dShape.html[`Convex2dShape`]
* {url-shape}/HeightfieldCollisionShape.html[`HeightfieldCollisionShape`]
* {url-shape}/PlaneCollisionShape.html[`PlaneCollisionShape`]
* {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`] with 1-to-3 vertices

Furthermore, the following shape classes are suitable *only*
for kinematic or static objects because
the simulator cannot determine their mass distributions:

* {url-shape}/EmptyShape.html[`EmptyShape`]
* {url-shape}/HeightfieldCollisionShape.html[`HeightfieldCollisionShape`]
* {url-shape}/MeshCollisionShape.html[`MeshCollisionShape`]
* {url-shape}/PlaneCollisionShape.html[`PlaneCollisionShape`]

The safest shapes for dynamic rigid bodies are the _primitives_ listed below.
All have at least one {url-enwiki}/Rotational_symmetry[axis of symmetry],
and their centers and axes are well-known:

* {url-shape}/BoxCollisionShape.html[`BoxCollisionShape`]
* {url-shape}/CapsuleCollisionShape.html[`CapsuleCollisionShape`]
* {url-shape}/ConeCollisionShape.html[`ConeCollisionShape`]
* {url-shape}/CylinderCollisionShape.html[`CylinderCollisionShape`]
* {url-shape}/SphereCollisionShape.html[`SphereCollisionShape`]

Many asymmetric shapes are also suitable for dynamic rigid bodies.
With such shapes, however, care should be taken to ensure the plausibility of
the center of mass and principal axes.
At the very least,
the shape's center should be located well inside its convex hull.

{url-tutorial}/HelloMadMallet.java[HelloMadMallet] is a simple
application that demonstrates the effect of an implausibly centered shape.
Things to notice while running the app:

. A dynamic rigid body, shaped like a mallet,
  falls under the influence of gravity.
. Unlike a real mallet, the body's center of mass (visualized by 3 arrows)
  is located at the end of its handle.
. After landing, the mallet tends to stand erect.
  Although this position seems unnatural, it is the precisely the one
  that will minimize the mallet's
  {url-enwiki}/Gravitational_potential[gravitational potential].

The following classes can generate asymmetric shapes for rigid bodies:

* {url-shape}/CompoundCollisionShape.html[`CompoundCollisionShape`]
* {url-shape}/GImpactCollisionShape.html[`GImpactCollisionShape`]
* {url-shape}/HullCollisionShape.html[`HullCollisionShape`]
* {url-shape}/MultiSphere.html[`MultiSphere`]
* {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`] with 4 vertices

In the case of a
{url-shape}/CompoundCollisionShape.html[`CompoundCollisionShape`],
the `principalAxes()` and `correctAxes()` methods
may be used to adjust its center and axes for a specific mass distribution.

{url-tutorial}/HelloMassDistribution.java[HelloMassDistribution] is a simple
application that demonstrates the use of `principalAxes()` and `correctAxes()`.
Things to notice while running the app:

. This time, the mallet's center of mass (visualized by 3 arrows)
  lies much closer to the head, in a very plausible location.
. After landing, the mallet comes to rest on its side,
  which is a more natural behavior for a mallet.

== Scaling

Some applications require collision shapes that are _scalable_
(can be dynamically shrunk or enlarged).
However, not all collision shapes can scale arbitrarily.
In particular:

* {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`]
  doesn't support scaling;
  the only allowed scale is (1,1,1).
* {url-shape}/CapsuleCollisionShape.html[`CapsuleCollisionShape`],
  {url-shape}/ConeCollisionShape.html[`ConeCollisionShape`], and
  {url-shape}/SphereCollisionShape.html[`SphereCollisionShape`]
  support only uniform scaling, where all axes have the same scale factor.
  For instance, (0.2,0.2,0.2) or (9,9,9).
* {url-shape}/CylinderCollisionShape.html[`CylinderCollisionShape`]
  allows the height and base to scale independently,
  but the scale factors of both base axes must be equal.
  In other words, the cross section must remain circular.
  So (9,9,9) would be allowed for any cylinder,
  but (9,1,1) would be allowed only for cylinders
  where the local X axis is the height axis.

You can test at runtime whether a particular scaling
is applicable to particular shape:

[source,java]
----
if (shape.canScale(newScale)) {
    shape.setScale(newScale);
}
----

== Choosing a shape

For efficient simulation, the general rule is:
"Use the simplest shape that yields the desired *behavior*."
By focusing on behavior rather than appearance,
you may avoid simulating details that don't matter.
For instance:

* A character's hair should probably be omitted from their collision shape.
* Any small shape that only encounters large, flat surfaces
  can probably be approximated by a convex hull.
* If a transparent container remains sealed,
  its collision shape need not be hollow.

Because jMonkeyEngine models are composed of triangular meshes,
beginners are often tempted to use mesh-based shapes
(such as {url-shape}/GImpactCollisionShape.html[`GImpactCollisionShape`])
for everything.
However, since mesh-based collision detection is CPU-intensive,
simpler shapes are often a better choice,
even when they don't match the model's shape closely.
In particular, {url-shape}/CapsuleCollisionShape.html[`CapsuleCollisionShape`]
is often used with humanoid models.

The following pseudo-code algorithm may be helpful:

----
if (the object doesn't move and isn't involved in collisions) {
    use an EmptyShape or don't add the object to the space
} else if (the object doesn't move
           and its shape can be approximated by an infinite plane) {
    use a PlaneCollisionShape
} else if (the object doesn't move
          and its shape can be approximated by point, line segment, or triangle) {
    use a SimplexCollisionShape
} else if (the object doesn't move
           and its shape can be approximated by rectangle) {
    use a Box2dShape
} else if (the object doesn't move
           and its shape can be approximated by 2-D convex polygon) {
    use a Convex2dShape
} else if (its shape can be approximated by a tetrahedron) {
    use a SimplexCollisionShape
} else if (its shape can be approximated by a centered sphere) {
    use a SphereCollisionShape
} else if (its shape can be approximated by a centered rectangular solid) {
    use a BoxCollisionShape
} else if (its shape can be approximated by a centered capsule) {
    use a CapsuleCollisionShape
} else if (its shape can be approximated by a centered cylinder) {
    use a CylinderCollisionShape
} else if (its shape can be approximated by a centered cone) {
    use a ConeCollisionShape
} else if (its shape can be approximated by an ellipsoid
           or an eccentric sphere
           or an eccentric capsule
           or the convex hull of multiple spheres) {
    use a MultiSphere
} else if (its shape can be approximated by an eccentric primitive
           or a combination of convex primitives) {
    use a CompoundCollisionShape
} else if (the object does not move) {
    if (it is a 2-D heightfield) {
        use a HeightfieldCollisionShape
    } else {
        use a MeshCollisionShape
    }
} else { // if the object moves
    if (its shape can be approximated by a convex hull) {
        use a HullCollisionShape
    } else if (its shape can be decomposed into convex hulls) {
        use a compound of hull shapes
    } else {
        use a GImpactCollisionShape
    }
}
----

(Pseudocode adapted from the flowchart on page 13 of
https://github.com/bulletphysics/bullet3/blob/master/docs/Bullet_User_Manual.pdf[the Bullet User Manual].)

NOTE: `GImpactCollisionShape` should be your last resort!

== Convex decomposition

Faced with simulating a non-convex object such as a ring,
it's best to decompose it into convex shapes that,
when recombined, will approximate the desired behavior.

There are various approaches,
depending on what the developer knows about the object's shape.
If the model's mesh is generated procedurally, it may be possible
to decompose it during the generation process.
Or if the object is modelled in Blender,
it may be practical to manually decompose it there
into meshes that are convex or nearly so.
In both cases, the desired compound shape can then be generated using
`CollisionShapeFactory.createDynamicMeshShape()`.

For situations where manual decomposition is impractical,
Minie incorporates Khaled Mamou's
https://github.com/kmammou/v-hacd[Volumetric-Hierarchical Approximate Convex Decomposition (V-HACD) algorithm].
V-HACD makes it easy to decompose a 3-D model into a
compound of hull shapes:

[source,java]
----
VHACDParameters parms = new VHACDParameters();
CollisionShape shape
        = CollisionShapeFactory.createVhacdShape(modelRoot, parms, null);
----

The V-HACD algorithm is costly to run, but in many applications it can
be run during in advance and stored in J3O format until needed.
During simulation, the resulting shape will usually be much more efficient
than a `GImpactCollisionShape`.

== Summary

* Minie provides 16 types of collision shapes,
  ranging from the trivial {url-shape}/EmptyShape.html[`EmptyShape`]
  to the costly {url-shape}/GImpactCollisionShape.html[`GImpactCollisionShape`].
* Collision-shape instances classified as "concave"
  may still exhibit the convex property.
* Most collision shapes incorporate a margin.
* Margin distorts the effective shape of imprecise collision shapes.
* Most collision shapes can be scaled, but not all can be scaled non-uniformly.
* Not all collision shapes are suitable for dynamic rigid bodies.
* When applying a non-symmetric shape to a dynamic rigid body,
  make sure that the center and principal axes are reasonable.
* Use the simplest shape that yields the desired behavior.
* To speed up simulation of objects with non-convex shapes,
  decompose them into convex ones, either by hand or using V-HACD.
